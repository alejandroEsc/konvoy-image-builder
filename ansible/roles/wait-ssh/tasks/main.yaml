---
- block:
  # a implementation of wait_for_connection without requiring Python on the host

  - set_fact:
      ssh_private_key_file_args:
        - -i
        - "{{ ansible_ssh_private_key_file }}"
    when:
      - ansible_ssh_private_key_file is defined
      - ansible_ssh_private_key_file != ''

  - set_fact:
      ssh_args:
        - -o
        - "UserKnownHostsFile=/dev/null"
        - -o
        - "StrictHostKeyChecking=no"
        - -o
        - "ConnectTimeout={{ extraRunnerVars.ssh_up_check_conn_timeout | default(10) }}"
        - -p
        - "{{ ansible_port|default(22) }}"
        - -l
        - "{{ ansible_user }}"
        - '{{ hostvars[inventory_hostname]["ansible_host"]|default(inventory_hostname) }}'
        - whoami

  - set_fact:
      ssh_args: "{{ ssh_private_key_file_args + ssh_args }}"
    when:
      - ansible_ssh_private_key_file is defined
      - ansible_ssh_private_key_file != ''

  - name: "wait {{ extraRunnerVars.ssh_up_check_timeout | default(180) }} seconds for SSH target connection to become reachable"
    command:
      cmd: ssh {{ ssh_args | join(' ') }}
      chdir: "{{ working_directory }}"
    delegate_to: localhost
    become: no
    changed_when: false
    register: direct_ssh_run
    until: direct_ssh_run is succeeded
    retries: "{{ extraRunnerVars.ssh_up_check_max_retries | default(5) }}"
    delay: "{{ (extraRunnerVars.ssh_up_check_timeout | default('180')) | int  - (extraRunnerVars.ssh_up_check_conn_timeout | default('10')) | int }}"
    when: >
      groups['bastion'] is not defined or
      groups["bastion"] | length == 0 or
      inventory_hostname in groups["bastion"]

  - debug:
      msg: 'Unable to verify reachability of non-bastion nodes due to bastion host being exluded from play'
    run_once: yes
    when: >
      groups['bastion'] is defined and
      groups["bastion"] | length > 0 and
      groups["bastion"][0] not in ansible_play_hosts_all

  # Checking hosts behind bastion is tricky, as we cannot rely on bastion
  # hosts having:
  # * python installed (no `delegate_to`)
  # * ssh-key for the cluster nodes
  # * TCP port forwarding for SSHd server enabled
  # The idea is to launch our own ssh-agent and execute ssh command on the
  # bastion hosts using plain ssh. This way we do not require any extra
  # privileges on the bastion host and are as close to the way the user would
  # have normally done it as possible. SSH agent forwarding is also a client
  # feature and can't be blocked on the bastion host.
  #
  # Another thing is the situation when the bastion host itself is unhealthy -
  # we then skip running this test altogether and rely on provisioning retries
  # to try again later on. Otherwise we may end up with reprovisioning the
  # whole cluster needlesly.
  #
  # This uses one bastion host (groups['bastion'][0]) because, if you alternate
  # between bastion hosts, the SSH credentials defined in inventory.yaml will
  # not be used and the defaults will be used instead. The cause for that is
  # likely a cache holding the SSH information for `delegate_to` only for the
  # first host.
  #
  # NOTE(prozlach): Putting `inventory_hostname not in groups['bastion']`
  # condition in task scope instead of block scope is dictated by how ansible
  # executes tasks with `run_once: true` attribute set. Block-scoped condition
  # prevents them from executing.
  - name: "verify hosts behind bastion {{ groups['bastion'][0] }}"
    block:
    - name: start temporary ssh-agent
      command:
        argv:
          - ssh-agent
          - -s
      register: ssh_agent_run
      ignore_errors: true
      run_once: true
      changed_when: false

    - name: find ssh-agent facts
      set_fact:
        ssh_auth_sock: '{{ ssh_agent_run.stdout | regex_search("SSH_AUTH_SOCK=[^;\s]+", multiline=True) | regex_replace("^SSH_AUTH_SOCK=", "") | string }}'
        ssh_agent_pid: '{{ ssh_agent_run.stdout | regex_search("SSH_AGENT_PID=\d+", multiline=True) | regex_replace("^SSH_AGENT_PID=", "") | string }}'
      run_once: true

    - name: add cluster ssh key to the temporary ssh agent
      command:
        argv:
          - ssh-add
          - "{{ ansible_ssh_private_key_file }}"
        chdir: "{{ working_directory }}"
      register: ssh_add_run
      run_once: true
      ignore_errors: true
      changed_when: false
      environment:
        SSH_AUTH_SOCK: "{{ ssh_auth_sock }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"
      when: >
        ssh_agent_run is succeeded

    - debug:
        msg: 'Unable to verify non-bastion nodes reachability due temporary ssh agent setup failure'
      run_once: true
      when: >
        (ssh_agent_run is failed or ssh_add_run is failed) and
        inventory_hostname not in groups['bastion']

    - set_fact:
        ssh_args:
          - -o
          - "UserKnownHostsFile=/dev/null"
          - -o
          - "StrictHostKeyChecking=no"
          - -o
          - "ConnectTimeout={{ extraRunnerVars.ssh_up_check_conn_timeout | default(10) }}"
          - -p
          - '{{ hostvars[groups["bastion"][0]]["ansible_port"] | default(22) }}'
          - -l
          - "{{ ansible_user }}"
          - '{{ hostvars[groups["bastion"][0]]["ansible_host"] | default(groups["bastion"][0]) }}'
          - ssh
          - -V

    - set_fact:
        ssh_args: "{{ ssh_private_key_file_args + ssh_args }}"
      when:
        - ansible_ssh_private_key_file is defined
        - ansible_ssh_private_key_file != ''

    - name: 'check if bastion host {{ groups["bastion"][0] }} has a usable ssh client'
      command:
        cmd: ssh {{ ssh_args | join(' ') }}
        chdir: "{{ working_directory }}"
      register: ssh_client_check
      run_once: true
      changed_when: false
      ignore_errors: true
      when: >
        ssh_agent_run is succeeded and
        ssh_add_run is succeeded

    - debug:
        msg: 'Unable to verify non-bastion nodes reachability due to bastion host {{ groups["bastion"][0] }} missing SSH client'
      run_once: true
      when: >
        ssh_agent_run is succeeded and
        ssh_add_run is succeeded and
        ssh_client_check is failed and
        inventory_hostname not in groups['bastion']

    - set_fact:
        ssh_args:
          - -o
          - "UserKnownHostsFile=/dev/null"
          - -o
          - "StrictHostKeyChecking=no"
          - -o
          - "ConnectTimeout={{ extraRunnerVars.ssh_up_check_conn_timeout | default(10) }}"
          - -A
          - -p
          - '{{ hostvars[groups["bastion"][0]]["ansible_port"] | default(22) }}'
          - -l
          - "{{ ansible_user }}"
          - '{{ hostvars[groups["bastion"][0]]["ansible_host"] | default(groups["bastion"][0]) }}'
          - ssh
          - -o
          - "UserKnownHostsFile=/dev/null"
          - -o
          - "StrictHostKeyChecking=no"
          - -o
          - "ConnectTimeout={{ extraRunnerVars.ssh_up_check_conn_timeout | default(10) }}"
          - -p
          - "{{ ansible_port|default(22) }}"
          - -l
          - "{{ ansible_user }}"
          - "{{ hostvars[inventory_hostname]['ansible_host'] | default(inventory_hostname) }}"
          - whoami

    - set_fact:
        ssh_args: "{{ ssh_private_key_file_args + ssh_args }}"
      when:
        - ansible_ssh_private_key_file is defined
        - ansible_ssh_private_key_file != ''

    - name: "wait {{ extraRunnerVars.ssh_up_check_timeout | default(180) }} seconds for hosts behind bastion to become reachable"
      command:
        cmd: ssh {{ ssh_args | join(' ') }}
        chdir: "{{ working_directory }}"
      register: ssh_run
      until: ssh_run is succeeded
      retries: "{{ extraRunnerVars.ssh_up_check_max_retries | default(5) }}"
      delay: "{{ (extraRunnerVars.ssh_up_check_timeout | default('180')) | int  - (extraRunnerVars.ssh_up_check_conn_timeout | default('10')) | int }}"
      environment:
        SSH_AUTH_SOCK: "{{ ssh_auth_sock }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"
      when: >
        ssh_agent_run is succeeded and
        ssh_add_run is succeeded and
        inventory_hostname not in groups['bastion'] and
        ssh_client_check is succeeded
      changed_when: false

    always:
    - name: kill temporary ssh-agent
      command:
        argv:
          - ssh-agent
          - -k
      # If we fail here, the process will be killed with the container anyway
      ignore_errors: true
      environment:
        SSH_AUTH_SOCK: "{{ ssh_auth_sock }}"
        SSH_AGENT_PID: "{{ ssh_agent_pid }}"
      run_once: true
      changed_when: false

    delegate_to: localhost
    become: no
    when: >
      groups['bastion'] is defined and
      groups['bastion'] | length > 0 and
      groups["bastion"][0] in ansible_play_hosts_all and
      hostvars[groups["bastion"][0]]["direct_ssh_run"] is succeeded and
      ansible_ssh_private_key_file is defined and
      ansible_ssh_private_key_file != ''
  always:
  - name: random number generation
    set_fact:
      r: "{{ 999999 | random(start=100000) }}"
    run_once: yes
    when: gather_reachability_data

  - debug:
      var: reachability_data
      verbosity: 2
    run_once: yes

  # Randomizing file name is meant as a precaution so that we do not read stale
  # reachability data in go code. Sample contents of the file:
  # $ cat /tmp/reachability_data.893398.json | jq .
  # {
  #    "192.168.16.2-2222": "OK",
  #    "192.168.16.3-2222": "OK",
  #    "192.168.16.4-2222": "OK",
  #    "192.168.16.5-2222": "OK",
  #    "192.168.16.6-2222": "OK",
  #    "192.168.16.7-2222": "OK"
  # }
  - name: "output reachability data for all nodes to /tmp/reachability_data.{{ r }}.json"
    copy:
      content: "{{ reachability_data | to_nice_json }}"
      dest: "/tmp/reachability_data.{{ r }}.json"
    run_once: yes
    delegate_to: localhost
    become: false
    changed_when: false
    when: gather_reachability_data
